import requests
from typing import Dict, List, Optional
from bitcoinrpc.authproxy import AuthServiceProxy
from stacks_blockchain import (
    StacksMainnet,
    StacksTestnet,
    make_contract_call,
    get_balance,
)
import clarity
import json
import logging

class StacksPenTester:
    def __init__(self, network: str = "testnet", config_path: str = "config.json"):
        """
        Initialize the Stacks Blockchain Penetration Testing Framework
        
        Args:
            network (str): Network to test ('mainnet' or 'testnet')
            config_path (str): Path to configuration file
        """
        self.network = StacksTestnet() if network == "testnet" else StacksMainnet()
        self.logger = self._setup_logging()
        self.config = self._load_config(config_path)
        self.vulnerabilities = []
        
    def _setup_logging(self) -> logging.Logger:
        """Configure logging for the penetration testing framework"""
        logger = logging.getLogger('stacks_pentest')
        logger.setLevel(logging.INFO)
        handler = logging.FileHandler('pentest_results.log')
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        return logger

    def _load_config(self, config_path: str) -> Dict:
        """Load configuration from JSON file"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            self.logger.error(f"Configuration file not found: {config_path}")
            return {}

    def test_smart_contract_vulnerabilities(self, contract_address: str) -> List[Dict]:
        """
        Test smart contract for common vulnerabilities
        
        Args:
            contract_address (str): Address of the smart contract to test
        
        Returns:
            List[Dict]: List of identified vulnerabilities
        """
        vulnerabilities = []
        
        # Test for reentrancy vulnerabilities
        if self._check_reentrancy(contract_address):
            vulnerabilities.append({
                "type": "reentrancy",
                "severity": "high",
                "description": "Contract vulnerable to reentrancy attacks"
            })
        
        # Test for integer overflow
        if self._check_integer_overflow(contract_address):
            vulnerabilities.append({
                "type": "integer_overflow",
                "severity": "high",
                "description": "Contract vulnerable to integer overflow"
            })
        
        return vulnerabilities

    def _check_reentrancy(self, contract_address: str) -> bool:
        """Check for reentrancy vulnerabilities in the smart contract"""
        try:
            contract_source = self.network.get_contract_source(contract_address)
            # Look for potentially dangerous patterns
            dangerous_patterns = [
                "(contract-call?",
                "(as-contract",
                "(stx-transfer?"
            ]
            
            for pattern in dangerous_patterns:
                if pattern in contract_source:
                    # Further analysis needed
                    self.logger.warning(f"Potential reentrancy vulnerability found in {contract_address}")
                    return True
            return False
        except Exception as e:
            self.logger.error(f"Error checking reentrancy: {str(e)}")
            return False

    def _check_integer_overflow(self, contract_address: str) -> bool:
        """Check for integer overflow vulnerabilities"""
        try:
            contract_source = self.network.get_contract_source(contract_address)
            risky_operations = [
                "+",
                "*",
                "-"
            ]
            
            for operation in risky_operations:
                if operation in contract_source:
                    # Check if proper bounds checking is implemented
                    if "asserts!" not in contract_source:
                        self.logger.warning(f"Potential integer overflow vulnerability found in {contract_address}")
                        return True
            return False
        except Exception as e:
            self.logger.error(f"Error checking integer overflow: {str(e)}")
            return False

    def check_network_security(self) -> Dict:
        """Check network-level security configurations"""
        security_report = {
            "node_version": self._check_node_version(),
            "peer_connections": self._check_peer_connections(),
            "open_ports": self._scan_open_ports(),
            "recommendations": []
        }
        
        return security_report

    def _check_node_version(self) -> str:
        """Check if node is running the latest version"""
        try:
            info = self.network.get_info()
            return info.get('stack_version', 'Unknown')
        except Exception as e:
            self.logger.error(f"Error checking node version: {str(e)}")
            return "Error"

    def _check_peer_connections(self) -> List[str]:
        """Check peer connections for potential security issues"""
        try:
            peers = self.network.get_peers()
            return [peer['address'] for peer in peers]
        except Exception as e:
            self.logger.error(f"Error checking peer connections: {str(e)}")
            return []

    def _scan_open_ports(self) -> List[int]:
        """Scan for open ports on the node"""
        common_ports = [20443, 20444, 8332, 8333]
        open_ports = []
        
        for port in common_ports:
            try:
                # Implement actual port scanning logic here
                pass
            except Exception as e:
                self.logger.error(f"Error scanning port {port}: {str(e)}")
                
        return open_ports

    def generate_report(self) -> Dict:
        """Generate a comprehensive security report"""
        return {
            "timestamp": logging.datetime.now().isoformat(),
            "network": "testnet" if isinstance(self.network, StacksTestnet) else "mainnet",
            "vulnerabilities": self.vulnerabilities,
            "network_security": self.check_network_security(),
            "recommendations": self._generate_recommendations()
        }

    def _generate_recommendations(self) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = []
        
        if self.vulnerabilities:
            for vuln in self.vulnerabilities:
                if vuln['severity'] == 'high':
                    recommendations.append(f"Critical: Fix {vuln['type']} vulnerability immediately")
                elif vuln['severity'] == 'medium':
                    recommendations.append(f"Important: Address {vuln['type']} vulnerability")
                    
        return recommendations

if __name__ == "__main__":
    # Example usage
    pentest = StacksPenTester(network="testnet")
    
    # Test a specific contract
    contract_address = "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM"
    vulnerabilities = pentest.test_smart_contract_vulnerabilities(contract_address)
    
    # Generate and save report
    report = pentest.generate_report()
    with open('security_report.json', 'w') as f:
        json.dump(report, f, indent=4)